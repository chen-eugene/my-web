##### 1、`let` 不存在变量提升，`var` 存在变量提升
- `var` 声明的变量会发生变量提升，即脚本开始运行的时候，变量就已经被定义，所以每一次循环新的`i`值
会覆盖掉旧值，导致最后输出的是最后一轮的`i`的值。

- `let`声明的变量不存在变量提升，当前的`i`只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。
    ```
    var a = [];
    for (var i = 0; i < 10; i++) {
      a[i] = function () {
        console.log(i);
      };
    }
    a[6](); // 10
    
    var a = [];
    for (let i = 0; i < 10; i++) {
      a[i] = function () {
        console.log(i);
      };
    }
    a[6](); // 6
    ```
##### 2、暂时性死区
- 如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。
凡是在声明之前就使用这些变量，就会报错。这在语法上，称为“暂时性死区”
    ```
    var tmp = 123;
    
    if (true) {
      tmp = 'abc'; // ReferenceError
      let tmp;
    }
    ```
- 使用`let`声明的变量，在声明之前，使用`typeof`会报错
    ```
    //变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。
    //因此，typeof运行时就会抛出一个ReferenceError。
    typeof x; // ReferenceError
    let x;
    ```
- `let` 不允许重复声明    

##### 3、`const`命令
- `const` 声明一个只读的常量。一旦声明，常量的值就不能改变。
- `const` 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
- `const` 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。

    
    
    



